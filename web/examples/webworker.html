<!DOCTYPE html>
<html lang="en">
<head>
    <title>dc.js - Filtering Example</title>
    <meta charset="UTF-8">
    <link rel="stylesheet" type="text/css" href="../css/bootstrap.min.css">
    <link rel="stylesheet" type="text/css" href="../css/dc.css"/>
</head>
<body>

<div class="container">
<script type="text/javascript" src="header.js"></script>
  <div id="chart-ring-year" style="width:300px; height:300px">
    <div class="reset" style="visibility: hidden;">selected: <span class="filter"></span>
      <a href="javascript:yearRingChart.filterAll();dc.redrawAll();">reset</a>
    </div>
  </div>
  <div id="chart-hist-spend" style="width:300px; height:300px">
    <div class="reset" style="visibility: hidden;">range: <span class="filter"></span>
      <a href="javascript:spendHistChart.filterAll();dc.redrawAll();">reset</a>
    </div>
  </div>
  <div id="chart-row-spenders">
    <div class="reset" style="visibility: hidden;">selected: <span class="filter"></span>
      <a href="javascript:spenderRowChart.filterAll();dc.redrawAll();">reset</a>
    </div>
  </div>

<script type="text/javascript" src="../js/d3.js"></script>
<script type="text/javascript" src="../js/operative.js"></script>
<script type="text/javascript" src="../js/crossfilter-async.js"></script>
<!-- dc needs this for sort #1161 -->
<script type="text/javascript" src="../js/crossfilter.js"></script>
<script type="text/javascript" src="../js/dc.js"></script>
<script type="text/javascript">

  var yearRingChart   = dc.pieChart("#chart-ring-year"),
  spendHistChart  = dc.barChart("#chart-hist-spend"),
  spenderRowChart = dc.rowChart("#chart-row-spenders");

  // woof! so much data! clearly we need a webworker! :)
  var spendData = [
      {Name: 'Mr A', Spent: '$40', Year: 2011},
      {Name: 'Mr B', Spent: '$10', Year: 2011},
      {Name: 'Mr C', Spent: '$40', Year: 2011},
      {Name: 'Mr A', Spent: '$70', Year: 2012},
      {Name: 'Mr B', Spent: '$20', Year: 2012},
      {Name: 'Mr B', Spent: '$50', Year: 2013},
      {Name: 'Mr C', Spent: '$30', Year: 2013}
  ];

  // normalize/parse data
  spendData.forEach(function(d) {
      d.Spent = d.Spent.match(/\d+/);
  });

  // set crossfilter
  var ndx = crossfilterAsync(spendData, "../js/crossfilter.js"),
      yearDim  = ndx.dimension(function(d) {return +d.Year;}),
      spendDim = ndx.dimension(function(d) {return Math.floor(d.Spent/10);}),
      nameDim  = ndx.dimension(function(d) {return d.Name;}),
      spendPerYear = yearDim.group().reduceSum(function(d) {return +d.Spent;}),
      spendPerName = nameDim.group().reduceSum(function(d) {return +d.Spent;}),
      spendHist    = spendDim.group().reduceCount();

  // if this works, these dimension and group "holders" should go in a little library somewhere
  function dholder(dimensionAsync) {
      var _arg;
      function filter(arg) {
          _arg = arg;
          return this;
      }
      return {
          filter: filter,
          filterExact: filter,
          filterRange: function(range) {
              filter([range[0], range[1]]);
              return this;
          },
          commit: function() {
              if(_arg===undefined)
                  return Promise.resolve(undefined)
              else
                  return dimensionAsync.filter(_arg).then(function() {
                      _arg = undefined;
                  });
          }
      };
  }
  function gholder(groupAsync) {
      var _all;
      return {
          all: function() {
              return _all;
          },
          commit: function() {
              return groupAsync.all().then(function(all) {
                  _all = all;
              });
          }
      };
  }
  function iholder(asyncDims, asyncGroups) {
      function commit(async) {
          return async.commit();
      }
      return {
          commit: function(_, k) {
              return Promise.all(asyncDims.map(commit)).then(function() {
                  return Promise.all(asyncGroups.map(commit));
              }).then(function() {
                  k(null, undefined);
              }).catch(function(error) {
                  k(error, null);
              });
          }
      };
  }
  var yearDimH  = dholder(yearDim),
      spendDimH = dholder(spendDim),
      nameDimH  = dholder(nameDim),
      spendPerYearH = gholder(spendPerYear),
      spendPerNameH = gholder(spendPerName),
      spendHistH    = gholder(spendHist);
  var handler = iholder([yearDimH, spendDimH, nameDimH], [spendPerYearH, spendPerNameH, spendHistH]);

  handler.commit(true, function() {
      yearRingChart
          .commitHandler(handler.commit)
          .dimension(yearDimH)
          .group(spendPerYearH)
          .innerRadius(50)
          .controlsUseVisibility(true);

      spendHistChart
          .commitHandler(handler.commit)
          .dimension(spendDimH)
          .group(spendHistH)
          .x(d3.scale.linear().domain([0,10]))
          .elasticY(true)
          .controlsUseVisibility(true);

      spendHistChart.xAxis().tickFormat(function(d) {return d*10}); // convert back to base unit
      spendHistChart.yAxis().ticks(2);

      spenderRowChart
          .commitHandler(handler.commit)
          .dimension(nameDimH)
          .group(spendPerNameH)
          .elasticX(true)
          .controlsUseVisibility(true);

      dc.renderAll();
  });
</script>

</div>
</body>
</html>
