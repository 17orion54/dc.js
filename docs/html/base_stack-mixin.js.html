<!DOCTYPE html>

<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width">
	<title>dc.js Source: base/stack-mixin.js</title>

	<!--[if lt IE 9]>
	<script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
	<![endif]-->
	<link type="text/css" rel="stylesheet" href="styles/sunlight.default.css">

	<link type="text/css" rel="stylesheet" href="styles/site.cosmo.css">

</head>

<body>

<div class="navbar navbar-default navbar-fixed-top navbar-inverse">
<div class="container">
	<div class="navbar-header">
		<a class="navbar-brand" href="index.html">dc.js</a>
		<button class="navbar-toggle" type="button" data-toggle="collapse" data-target="#topNavigation">
			<span class="icon-bar"></span>
			<span class="icon-bar"></span>
			<span class="icon-bar"></span>
        </button>
	</div>
	<div class="navbar-collapse collapse" id="topNavigation">
		<ul class="nav navbar-nav">
			
			<li class="dropdown">
				<a href="namespaces.list.html" class="dropdown-toggle" data-toggle="dropdown">Namespaces<b class="caret"></b></a>
				<ul class="dropdown-menu ">
					<li><a href="dc.html">dc</a></li><li><a href="dc.chartRegistry.html">dc.chartRegistry</a></li><li><a href="dc.filters.html">dc.filters</a></li><li><a href="dc.printers.html">dc.printers</a></li><li><a href="dc.units.html">dc.units</a></li><li><a href="dc.units.fp.html">dc.units.fp</a></li><li><a href="dc.utils.html">dc.utils</a></li>
				</ul>
			</li>
			
			<li class="dropdown">
				<a href="classes.list.html" class="dropdown-toggle" data-toggle="dropdown">Classes<b class="caret"></b></a>
				<ul class="dropdown-menu ">
					<li><a href="dc.barChart.html">dc.barChart</a></li><li><a href="dc.boxPlot.html">dc.boxPlot</a></li><li><a href="dc.bubbleChart.html">dc.bubbleChart</a></li><li><a href="dc.bubbleOverlay.html">dc.bubbleOverlay</a></li><li><a href="dc.cboxMenu.html">dc.cboxMenu</a></li><li><a href="dc.compositeChart.html">dc.compositeChart</a></li><li><a href="dc.config.html">dc.config</a></li><li><a href="dc.dataCount.html">dc.dataCount</a></li><li><a href="dc.dataGrid.html">dc.dataGrid</a></li><li><a href="dc.dataTable.html">dc.dataTable</a></li><li><a href="dc.filters.HierarchyFilter.html">dc.filters.HierarchyFilter</a></li><li><a href="dc.filters.RangedFilter.html">dc.filters.RangedFilter</a></li><li><a href="dc.filters.RangedTwoDimensionalFilter.html">dc.filters.RangedTwoDimensionalFilter</a></li><li><a href="dc.filters.TwoDimensionalFilter.html">dc.filters.TwoDimensionalFilter</a></li><li><a href="dc.geoChoroplethChart.html">dc.geoChoroplethChart</a></li><li><a href="dc.heatMap.html">dc.heatMap</a></li><li><a href="dc.htmlLegend.html">dc.htmlLegend</a></li><li><a href="dc.Legend.html">dc.Legend</a></li><li><a href="dc.lineChart.html">dc.lineChart</a></li><li><a href="dc.logger.html">dc.logger</a></li><li><a href="dc.numberDisplay.html">dc.numberDisplay</a></li><li><a href="dc.pieChart.html">dc.pieChart</a></li><li><a href="dc.rowChart.html">dc.rowChart</a></li><li><a href="dc.scatterPlot.html">dc.scatterPlot</a></li><li><a href="dc.selectMenu.html">dc.selectMenu</a></li><li><a href="dc.seriesChart.html">dc.seriesChart</a></li><li><a href="dc.sunburstChart.html">dc.sunburstChart</a></li><li><a href="dc.textFilterWidget.html">dc.textFilterWidget</a></li>
				</ul>
			</li>
			
			<li class="dropdown">
				<a href="mixins.list.html" class="dropdown-toggle" data-toggle="dropdown">Mixins<b class="caret"></b></a>
				<ul class="dropdown-menu ">
					<li><a href="dc.baseMixin.html">dc.baseMixin</a></li><li><a href="dc.bubbleMixin.html">dc.bubbleMixin</a></li><li><a href="dc.capMixin.html">dc.capMixin</a></li><li><a href="dc.colorMixin.html">dc.colorMixin</a></li><li><a href="dc.coordinateGridMixin.html">dc.coordinateGridMixin</a></li><li><a href="dc.marginMixin.html">dc.marginMixin</a></li><li><a href="dc.stackMixin.html">dc.stackMixin</a></li>
				</ul>
			</li>
			
		</ul>
        
            <div class="col-sm-3 col-md-3">
                <form class="navbar-form" role="search">
                    <div class="input-group">
                        <input type="text" class="form-control" placeholder="Search" name="q" id="search-input">
                        <div class="input-group-btn">
                            <button class="btn btn-default" id="search-submit"><i class="glyphicon glyphicon-search"></i></button>
                        </div>
                    </div>
                </form>
            </div>
        
	</div>

</div>
</div>


<div class="container" id="toc-content">
<div class="row">

	
	<div class="col-md-12">
	
		<div id="main">
			

		<h1 class="page-title">Source: base/stack-mixin.js</h1>
    
<section>
    <article>
        <pre
            class="sunlight-highlight-javascript linenums">import * as d3 from 'd3';

import {pluck, utils} from '../core/utils';

/**
 * Stack Mixin is an mixin that provides cross-chart support of stackability using d3.stackD3v3.
 * @name stackMixin
 * @memberof dc
 * @mixin
 * @param {Object} Base
 * @returns {dc.stackMixin}
 */
export const StackMixin = Base => {
    return class extends Base {
        constructor () {
            super();

            this._stackLayout = d3.stack();

            this._stack = [];
            this._titles = {};

            this._hidableStacks = false;
            this._evadeDomainFilter = false;

            this.data(() => {
                const layers = this._stack.filter(this._visibility);
                if (!layers.length) {
                    return [];
                }
                layers.forEach((l, i) => this._prepareValues(l, i));
                const v4data = layers[0].values.map((v, i) => {
                    const col = {x: v.x};
                    layers.forEach(layer => {
                        col[layer.name] = layer.values[i].y;
                    });
                    return col;
                });
                const keys = layers.map(layer => layer.name);
                const v4result = this.stackLayout().keys(keys)(v4data);
                v4result.forEach((series, i) => {
                    series.forEach((ys, j) => {
                        layers[i].values[j].y0 = ys[0];
                        layers[i].values[j].y1 = ys[1];
                    });
                });
                return layers;
            });

            this.colorAccessor(function (d) {
                return this.layer || this.name || d.name || d.layer;
            });
        }

        _prepareValues (layer, layerIdx) {
            const valAccessor = layer.accessor || this.valueAccessor();
            layer.name = String(layer.name || layerIdx);
            const allValues = layer.group.all().map((d, i) => ({
                x: this.keyAccessor()(d, i),
                y: layer.hidden ? null : valAccessor(d, i),
                data: d,
                layer: layer.name,
                hidden: layer.hidden
            }));

            layer.domainValues = allValues.filter(l => this._domainFilter()(l));
            layer.values = this.evadeDomainFilter() ? allValues : layer.domainValues;
        }

        _domainFilter () {
            if (!this.x()) {
                return utils.constant(true);
            }
            const xDomain = this.x().domain();
            if (this.isOrdinal()) {
                // TODO #416
                //var domainSet = d3.set(xDomain);
                return () => {
                    return true; //domainSet.has(p.x);
                };
            }
            if (this.elasticX()) {
                return () => true;
            }
            return p => {
                //return true;
                return p.x >= xDomain[0] &amp;&amp; p.x &lt;= xDomain[xDomain.length - 1];
            };
        }

        /**
         * Stack a new crossfilter group onto this chart with an optional custom value accessor. All stacks
         * in the same chart will share the same key accessor and therefore the same set of keys.
         *
         * For example, in a stacked bar chart, the bars of each stack will be positioned using the same set
         * of keys on the x axis, while stacked vertically. If name is specified then it will be used to
         * generate the legend label.
         * @method stack
         * @memberof dc.stackMixin
         * @instance
         * @see {@link https://github.com/crossfilter/crossfilter/wiki/API-Reference#group-map-reduce crossfilter.group}
         * @example
         * // stack group using default accessor
         * chart.stack(valueSumGroup)
         * // stack group using custom accessor
         * .stack(avgByDayGroup, function(d){return d.value.avgByDay;});
         * @param {crossfilter.group} group
         * @param {String} [name]
         * @param {Function} [accessor]
         * @returns {Array&lt;{group: crossfilter.group, name: String, accessor: Function}>|dc.stackMixin}
         */
        stack (group, name, accessor) {
            if (!arguments.length) {
                return this._stack;
            }

            if (arguments.length &lt;= 2) {
                accessor = name;
            }

            const layer = {group: group};
            if (typeof name === 'string') {
                layer.name = name;
            }
            if (typeof accessor === 'function') {
                layer.accessor = accessor;
            }
            this._stack.push(layer);

            return this;
        }

        group (g, n, f) {
            if (!arguments.length) {
                return super.group();
            }
            this._stack = [];
            this._titles = {};
            this.stack(g, n);
            if (f) {
                this.valueAccessor(f);
            }
            return super.group(g, n);
        }

        /**
         * Allow named stacks to be hidden or shown by clicking on legend items.
         * This does not affect the behavior of hideStack or showStack.
         * @method hidableStacks
         * @memberof dc.stackMixin
         * @instance
         * @param {Boolean} [hidableStacks=false]
         * @returns {Boolean|dc.stackMixin}
         */
        hidableStacks (hidableStacks) {
            if (!arguments.length) {
                return this._hidableStacks;
            }
            this._hidableStacks = hidableStacks;
            return this;
        }

        _findLayerByName (n) {
            const i = this._stack.map(pluck('name')).indexOf(n);
            return this._stack[i];
        }

        /**
         * Hide all stacks on the chart with the given name.
         * The chart must be re-rendered for this change to appear.
         * @method hideStack
         * @memberof dc.stackMixin
         * @instance
         * @param {String} stackName
         * @returns {dc.stackMixin}
         */
        hideStack (stackName) {
            const layer = this._findLayerByName(stackName);
            if (layer) {
                layer.hidden = true;
            }
            return this;
        }

        /**
         * Show all stacks on the chart with the given name.
         * The chart must be re-rendered for this change to appear.
         * @method showStack
         * @memberof dc.stackMixin
         * @instance
         * @param {String} stackName
         * @returns {dc.stackMixin}
         */
        showStack (stackName) {
            const layer = this._findLayerByName(stackName);
            if (layer) {
                layer.hidden = false;
            }
            return this;
        }

        getValueAccessorByIndex (index) {
            return this._stack[index].accessor || this.valueAccessor();
        }

        yAxisMin () {
            const min = d3.min(this._flattenStack(), p => (p.y &lt; 0) ? (p.y + p.y0) : p.y0);
            return utils.subtract(min, this.yAxisPadding());
        }

        yAxisMax () {
            const max = d3.max(this._flattenStack(), p => (p.y > 0) ? (p.y + p.y0) : p.y0);
            return utils.add(max, this.yAxisPadding());
        }

        _flattenStack () {
            // A round about way to achieve flatMap
            // When target browsers support flatMap, just replace map -> flatMap, no concat needed
            const values = this.data().map(layer => layer.domainValues);
            return [].concat(...values);
        }

        xAxisMin () {
            const min = d3.min(this._flattenStack(), pluck('x'));
            return utils.subtract(min, this.xAxisPadding(), this.xAxisPaddingUnit());
        }

        xAxisMax () {
            const max = d3.max(this._flattenStack(), pluck('x'));
            return utils.add(max, this.xAxisPadding(), this.xAxisPaddingUnit());
        }

        /**
         * Set or get the title function. Chart class will use this function to render svg title (usually interpreted by
         * browser as tooltips) for each child element in the chart, i.e. a slice in a pie chart or a bubble in a bubble chart.
         * Almost every chart supports title function however in grid coordinate chart you need to turn off brush in order to
         * use title otherwise the brush layer will block tooltip trigger.
         *
         * If the first argument is a stack name, the title function will get or set the title for that stack. If stackName
         * is not provided, the first stack is implied.
         * @method title
         * @memberof dc.stackMixin
         * @instance
         * @example
         * // set a title function on 'first stack'
         * chart.title('first stack', function(d) { return d.key + ': ' + d.value; });
         * // get a title function from 'second stack'
         * var secondTitleFunction = chart.title('second stack');
         * @param {String} [stackName]
         * @param {Function} [titleAccessor]
         * @returns {String|dc.stackMixin}
         */
        title (stackName, titleAccessor) {
            if (!stackName) {
                return super.title();
            }

            if (typeof stackName === 'function') {
                return super.title(stackName);
            }
            if (stackName === this._groupName &amp;&amp; typeof titleAccessor === 'function') {
                return super.title(titleAccessor);
            }

            if (typeof titleAccessor !== 'function') {
                return this._titles[stackName] || super.title();
            }

            this._titles[stackName] = titleAccessor;

            return this;
        }

        /**
         * Gets or sets the stack layout algorithm, which computes a baseline for each stack and
         * propagates it to the next.
         * @method stackLayout
         * @memberof dc.stackMixin
         * @instance
         * @see {@link https://github.com/d3/d3-3.x-api-reference/blob/master/Stack-Layout.md d3.stackD3v3}
         * @param {Function} [stack=d3.stackD3v3]
         * @returns {Function|dc.stackMixin}
         */
        stackLayout (stack) {
            if (!arguments.length) {
                return this._stackLayout;
            }
            this._stackLayout = stack;
            return this;
        }

        /**
         * Since dc.js 2.0, there has been {@link https://github.com/dc-js/dc.js/issues/949 an issue}
         * where points are filtered to the current domain. While this is a useful optimization, it is
         * incorrectly implemented: the next point outside the domain is required in order to draw lines
         * that are clipped to the bounds, as well as bars that are partly clipped.
         *
         * A fix will be included in dc.js 2.1.x, but a workaround is needed for dc.js 2.0 and until
         * that fix is published, so set this flag to skip any filtering of points.
         *
         * Once the bug is fixed, this flag will have no effect, and it will be deprecated.
         * @method evadeDomainFilter
         * @memberof dc.stackMixin
         * @instance
         * @param {Boolean} [evadeDomainFilter=false]
         * @returns {Boolean|dc.stackMixin}
         */
        evadeDomainFilter (evadeDomainFilter) {
            if (!arguments.length) {
                return this._evadeDomainFilter;
            }
            this._evadeDomainFilter = evadeDomainFilter;
            return this;
        }

        _visibility (l) {
            return !l.hidden;
        }

        _ordinalXDomain () {
            const flat = this._flattenStack().map(pluck('data'));
            const ordered = this._computeOrderedGroups(flat);
            return ordered.map(this.keyAccessor());
        }

        legendables () {
            return this._stack.map((layer, i) => ({
                chart: this,
                name: layer.name,
                hidden: layer.hidden || false,
                color: this.getColor.call(layer, layer.values, i)
            }));
        }

        isLegendableHidden (d) {
            const layer = this._findLayerByName(d.name);
            return layer ? layer.hidden : false;
        }

        legendToggle (d) {
            if (this._hidableStacks) {
                if (this.isLegendableHidden(d)) {
                    this.showStack(d.name);
                } else {
                    this.hideStack(d.name);
                }
                //_chart.redraw();
                this.renderGroup();
            }
        }
    }
};
</pre>
    </article>
</section>





		</div>
	</div>

	<div class="clearfix"></div>

	

</div>
</div>


    <div class="modal fade" id="searchResults">
      <div class="modal-dialog">
        <div class="modal-content">
          <div class="modal-header">
            <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
            <h4 class="modal-title">Search results</h4>
          </div>
          <div class="modal-body"></div>
          <div class="modal-footer">
            <button type="button" class="btn btn-default" data-dismiss="modal">Close</button>
          </div>
        </div><!-- /.modal-content -->
      </div><!-- /.modal-dialog -->
    </div>


<footer>


	<span class="copyright">
	dc.js Copyright © 2012-2018 Nick Zhu & the dc.js Developers
	</span>

<span class="jsdoc-message">
	Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.3</a>
	
		on Thu Sep 19th 2019
	
	using the <a href="https://github.com/docstrap/docstrap">DocStrap template</a>.
</span>
</footer>

<script src="scripts/docstrap.lib.js"></script>
<script src="scripts/toc.js"></script>

    <script type="text/javascript" src="scripts/fulltext-search-ui.js"></script>


<script>
$( function () {
	$( "[id*='$']" ).each( function () {
		var $this = $( this );

		$this.attr( "id", $this.attr( "id" ).replace( "$", "__" ) );
	} );

	$( ".tutorial-section pre, .readme-section pre, pre.prettyprint.source" ).each( function () {
		var $this = $( this );

		var example = $this.find( "code" );
		exampleText = example.html();
		var lang = /{@lang (.*?)}/.exec( exampleText );
		if ( lang && lang[1] ) {
			exampleText = exampleText.replace( lang[0], "" );
			example.html( exampleText );
			lang = lang[1];
		} else {
			var langClassMatch = example.parent()[0].className.match(/lang\-(\S+)/);
			lang = langClassMatch ? langClassMatch[1] : "javascript";
		}

		if ( lang ) {

			$this
			.addClass( "sunlight-highlight-" + lang )
			.addClass( "linenums" )
			.html( example.html() );

		}
	} );

	Sunlight.highlightAll( {
		lineNumbers : true,
		showMenu : true,
		enableDoclinks : true
	} );

	$.catchAnchorLinks( {
        navbarOffset: 10
	} );
	$( "#toc" ).toc( {
		anchorName  : function ( i, heading, prefix ) {
			return $( heading ).attr( "id" ) || ( prefix + i );
		},
		selectors   : "#toc-content h1,#toc-content h2,#toc-content h3,#toc-content h4",
		showAndHide : false,
		smoothScrolling: true
	} );

	$( "#main span[id^='toc']" ).addClass( "toc-shim" );
	$( '.dropdown-toggle' ).dropdown();

    $( "table" ).each( function () {
      var $this = $( this );
      $this.addClass('table');
    } );

} );
</script>



<!--Navigation and Symbol Display-->


<!--Google Analytics-->



    <script type="text/javascript">
        $(document).ready(function() {
            SearcherDisplay.init();
        });
    </script>


</body>
</html>
